### This file was autogenerated by GraphQL Nexus
### Do not make changes to this file directly


type AggregateDepartment {
  count: Int!
}

type AggregateEmployee {
  count: Int!
}

type AggregateOffice {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Department {
  employees(after: String, before: String, first: Int, last: Int, orderBy: EmployeeOrderByInput, skip: Int, where: EmployeeWhereInput): [Employee!]
  id: ID!
  lead: Employee
  name: String!
}

type DepartmentConnection {
  aggregate: AggregateDepartment!
  edges: [DepartmentEdge!]!
  pageInfo: PageInfo!
}

input DepartmentCreateInput {
  employees: EmployeeCreateManyWithoutDepartmentInput
  id: ID
  lead: EmployeeCreateOneWithoutLeadsInput
  name: String!
}

input DepartmentCreateOneWithoutEmployeesInput {
  connect: DepartmentWhereUniqueInput
  create: DepartmentCreateWithoutEmployeesInput
}

input DepartmentCreateOneWithoutLeadInput {
  connect: DepartmentWhereUniqueInput
  create: DepartmentCreateWithoutLeadInput
}

input DepartmentCreateWithoutEmployeesInput {
  id: ID
  lead: EmployeeCreateOneWithoutLeadsInput
  name: String!
}

input DepartmentCreateWithoutLeadInput {
  employees: EmployeeCreateManyWithoutDepartmentInput
  id: ID
  name: String!
}

type DepartmentEdge {
  cursor: String!
  node: Department!
}

enum DepartmentOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input DepartmentUpdateInput {
  employees: EmployeeUpdateManyWithoutDepartmentInput
  lead: EmployeeUpdateOneWithoutLeadsInput
  name: String
}

input DepartmentUpdateManyMutationInput {
  name: String
}

input DepartmentUpdateOneWithoutEmployeesInput {
  connect: DepartmentWhereUniqueInput
  create: DepartmentCreateWithoutEmployeesInput
  delete: Boolean
  disconnect: Boolean
  update: DepartmentUpdateWithoutEmployeesDataInput
  upsert: DepartmentUpsertWithoutEmployeesInput
}

input DepartmentUpdateOneWithoutLeadInput {
  connect: DepartmentWhereUniqueInput
  create: DepartmentCreateWithoutLeadInput
  delete: Boolean
  disconnect: Boolean
  update: DepartmentUpdateWithoutLeadDataInput
  upsert: DepartmentUpsertWithoutLeadInput
}

input DepartmentUpdateWithoutEmployeesDataInput {
  lead: EmployeeUpdateOneWithoutLeadsInput
  name: String
}

input DepartmentUpdateWithoutLeadDataInput {
  employees: EmployeeUpdateManyWithoutDepartmentInput
  name: String
}

input DepartmentUpsertWithoutEmployeesInput {
  create: DepartmentCreateWithoutEmployeesInput!
  update: DepartmentUpdateWithoutEmployeesDataInput!
}

input DepartmentUpsertWithoutLeadInput {
  create: DepartmentCreateWithoutLeadInput!
  update: DepartmentUpdateWithoutLeadDataInput!
}

input DepartmentWhereInput {
  AND: [DepartmentWhereInput!]
  employees_every: EmployeeWhereInput
  employees_none: EmployeeWhereInput
  employees_some: EmployeeWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  lead: EmployeeWhereInput
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [DepartmentWhereInput!]
  OR: [DepartmentWhereInput!]
}

input DepartmentWhereUniqueInput {
  id: ID
  name: String
}

type Employee {
  department: Department
  email: String!
  firstName: String!
  id: ID!
  lastName: String!
  leads: Department
  office: Office
}

type EmployeeConnection {
  aggregate: AggregateEmployee!
  edges: [EmployeeEdge!]!
  pageInfo: PageInfo!
}

input EmployeeCreateInput {
  department: DepartmentCreateOneWithoutEmployeesInput
  email: String!
  firstName: String!
  id: ID
  lastName: String!
  leads: DepartmentCreateOneWithoutLeadInput
  office: OfficeCreateOneWithoutEmployeesInput
}

input EmployeeCreateManyWithoutDepartmentInput {
  connect: [EmployeeWhereUniqueInput!]
  create: [EmployeeCreateWithoutDepartmentInput!]
}

input EmployeeCreateManyWithoutOfficeInput {
  connect: [EmployeeWhereUniqueInput!]
  create: [EmployeeCreateWithoutOfficeInput!]
}

input EmployeeCreateOneWithoutLeadsInput {
  connect: EmployeeWhereUniqueInput
  create: EmployeeCreateWithoutLeadsInput
}

input EmployeeCreateWithoutDepartmentInput {
  email: String!
  firstName: String!
  id: ID
  lastName: String!
  leads: DepartmentCreateOneWithoutLeadInput
  office: OfficeCreateOneWithoutEmployeesInput
}

input EmployeeCreateWithoutLeadsInput {
  department: DepartmentCreateOneWithoutEmployeesInput
  email: String!
  firstName: String!
  id: ID
  lastName: String!
  office: OfficeCreateOneWithoutEmployeesInput
}

input EmployeeCreateWithoutOfficeInput {
  department: DepartmentCreateOneWithoutEmployeesInput
  email: String!
  firstName: String!
  id: ID
  lastName: String!
  leads: DepartmentCreateOneWithoutLeadInput
}

type EmployeeEdge {
  cursor: String!
  node: Employee!
}

enum EmployeeOrderByInput {
  createdAt_ASC
  createdAt_DESC
  email_ASC
  email_DESC
  firstName_ASC
  firstName_DESC
  id_ASC
  id_DESC
  lastName_ASC
  lastName_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input EmployeeScalarWhereInput {
  AND: [EmployeeScalarWhereInput!]
  email: String
  email_contains: String
  email_ends_with: String
  email_gt: String
  email_gte: String
  email_in: [String!]
  email_lt: String
  email_lte: String
  email_not: String
  email_not_contains: String
  email_not_ends_with: String
  email_not_in: [String!]
  email_not_starts_with: String
  email_starts_with: String
  firstName: String
  firstName_contains: String
  firstName_ends_with: String
  firstName_gt: String
  firstName_gte: String
  firstName_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_not: String
  firstName_not_contains: String
  firstName_not_ends_with: String
  firstName_not_in: [String!]
  firstName_not_starts_with: String
  firstName_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  lastName: String
  lastName_contains: String
  lastName_ends_with: String
  lastName_gt: String
  lastName_gte: String
  lastName_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_not: String
  lastName_not_contains: String
  lastName_not_ends_with: String
  lastName_not_in: [String!]
  lastName_not_starts_with: String
  lastName_starts_with: String
  NOT: [EmployeeScalarWhereInput!]
  OR: [EmployeeScalarWhereInput!]
}

input EmployeeUpdateInput {
  department: DepartmentUpdateOneWithoutEmployeesInput
  email: String
  firstName: String
  lastName: String
  leads: DepartmentUpdateOneWithoutLeadInput
  office: OfficeUpdateOneWithoutEmployeesInput
}

input EmployeeUpdateManyDataInput {
  email: String
  firstName: String
  lastName: String
}

input EmployeeUpdateManyMutationInput {
  email: String
  firstName: String
  lastName: String
}

input EmployeeUpdateManyWithoutDepartmentInput {
  connect: [EmployeeWhereUniqueInput!]
  create: [EmployeeCreateWithoutDepartmentInput!]
  delete: [EmployeeWhereUniqueInput!]
  deleteMany: [EmployeeScalarWhereInput!]
  disconnect: [EmployeeWhereUniqueInput!]
  set: [EmployeeWhereUniqueInput!]
  update: [EmployeeUpdateWithWhereUniqueWithoutDepartmentInput!]
  updateMany: [EmployeeUpdateManyWithWhereNestedInput!]
  upsert: [EmployeeUpsertWithWhereUniqueWithoutDepartmentInput!]
}

input EmployeeUpdateManyWithoutOfficeInput {
  connect: [EmployeeWhereUniqueInput!]
  create: [EmployeeCreateWithoutOfficeInput!]
  delete: [EmployeeWhereUniqueInput!]
  deleteMany: [EmployeeScalarWhereInput!]
  disconnect: [EmployeeWhereUniqueInput!]
  set: [EmployeeWhereUniqueInput!]
  update: [EmployeeUpdateWithWhereUniqueWithoutOfficeInput!]
  updateMany: [EmployeeUpdateManyWithWhereNestedInput!]
  upsert: [EmployeeUpsertWithWhereUniqueWithoutOfficeInput!]
}

input EmployeeUpdateManyWithWhereNestedInput {
  data: EmployeeUpdateManyDataInput!
  where: EmployeeScalarWhereInput!
}

input EmployeeUpdateOneWithoutLeadsInput {
  connect: EmployeeWhereUniqueInput
  create: EmployeeCreateWithoutLeadsInput
  delete: Boolean
  disconnect: Boolean
  update: EmployeeUpdateWithoutLeadsDataInput
  upsert: EmployeeUpsertWithoutLeadsInput
}

input EmployeeUpdateWithoutDepartmentDataInput {
  email: String
  firstName: String
  lastName: String
  leads: DepartmentUpdateOneWithoutLeadInput
  office: OfficeUpdateOneWithoutEmployeesInput
}

input EmployeeUpdateWithoutLeadsDataInput {
  department: DepartmentUpdateOneWithoutEmployeesInput
  email: String
  firstName: String
  lastName: String
  office: OfficeUpdateOneWithoutEmployeesInput
}

input EmployeeUpdateWithoutOfficeDataInput {
  department: DepartmentUpdateOneWithoutEmployeesInput
  email: String
  firstName: String
  lastName: String
  leads: DepartmentUpdateOneWithoutLeadInput
}

input EmployeeUpdateWithWhereUniqueWithoutDepartmentInput {
  data: EmployeeUpdateWithoutDepartmentDataInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeUpdateWithWhereUniqueWithoutOfficeInput {
  data: EmployeeUpdateWithoutOfficeDataInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeUpsertWithoutLeadsInput {
  create: EmployeeCreateWithoutLeadsInput!
  update: EmployeeUpdateWithoutLeadsDataInput!
}

input EmployeeUpsertWithWhereUniqueWithoutDepartmentInput {
  create: EmployeeCreateWithoutDepartmentInput!
  update: EmployeeUpdateWithoutDepartmentDataInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeUpsertWithWhereUniqueWithoutOfficeInput {
  create: EmployeeCreateWithoutOfficeInput!
  update: EmployeeUpdateWithoutOfficeDataInput!
  where: EmployeeWhereUniqueInput!
}

input EmployeeWhereInput {
  AND: [EmployeeWhereInput!]
  department: DepartmentWhereInput
  email: String
  email_contains: String
  email_ends_with: String
  email_gt: String
  email_gte: String
  email_in: [String!]
  email_lt: String
  email_lte: String
  email_not: String
  email_not_contains: String
  email_not_ends_with: String
  email_not_in: [String!]
  email_not_starts_with: String
  email_starts_with: String
  firstName: String
  firstName_contains: String
  firstName_ends_with: String
  firstName_gt: String
  firstName_gte: String
  firstName_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_not: String
  firstName_not_contains: String
  firstName_not_ends_with: String
  firstName_not_in: [String!]
  firstName_not_starts_with: String
  firstName_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  lastName: String
  lastName_contains: String
  lastName_ends_with: String
  lastName_gt: String
  lastName_gte: String
  lastName_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_not: String
  lastName_not_contains: String
  lastName_not_ends_with: String
  lastName_not_in: [String!]
  lastName_not_starts_with: String
  lastName_starts_with: String
  leads: DepartmentWhereInput
  NOT: [EmployeeWhereInput!]
  office: OfficeWhereInput
  OR: [EmployeeWhereInput!]
}

input EmployeeWhereUniqueInput {
  email: String
  id: ID
}

scalar Long

type Mutation {
  createDepartment(data: DepartmentCreateInput!): Department!
  createEmployee(data: EmployeeCreateInput!): Employee!
  createOffice(data: OfficeCreateInput!): Office!
  deleteDepartment(where: DepartmentWhereUniqueInput!): Department
  deleteEmployee(where: EmployeeWhereUniqueInput!): Employee
  deleteManyDepartments(where: DepartmentWhereInput): BatchPayload!
  deleteManyEmployees(where: EmployeeWhereInput): BatchPayload!
  deleteManyOffices(where: OfficeWhereInput): BatchPayload!
  deleteOffice(where: OfficeWhereUniqueInput!): Office
  updateDepartment(data: DepartmentUpdateInput!, where: DepartmentWhereUniqueInput!): Department
  updateEmployee(data: EmployeeUpdateInput!, where: EmployeeWhereUniqueInput!): Employee
  updateManyDepartments(data: DepartmentUpdateManyMutationInput!, where: DepartmentWhereInput): BatchPayload!
  updateManyEmployees(data: EmployeeUpdateManyMutationInput!, where: EmployeeWhereInput): BatchPayload!
  updateManyOffices(data: OfficeUpdateManyMutationInput!, where: OfficeWhereInput): BatchPayload!
  updateOffice(data: OfficeUpdateInput!, where: OfficeWhereUniqueInput!): Office
  upsertDepartment(create: DepartmentCreateInput!, update: DepartmentUpdateInput!, where: DepartmentWhereUniqueInput!): Department!
  upsertEmployee(create: EmployeeCreateInput!, update: EmployeeUpdateInput!, where: EmployeeWhereUniqueInput!): Employee!
  upsertOffice(create: OfficeCreateInput!, update: OfficeUpdateInput!, where: OfficeWhereUniqueInput!): Office!
}

type Office {
  employees(after: String, before: String, first: Int, last: Int, orderBy: EmployeeOrderByInput, skip: Int, where: EmployeeWhereInput): [Employee!]
  id: ID!
  location: String!
  name: String!
}

type OfficeConnection {
  aggregate: AggregateOffice!
  edges: [OfficeEdge!]!
  pageInfo: PageInfo!
}

input OfficeCreateInput {
  employees: EmployeeCreateManyWithoutOfficeInput
  id: ID
  location: String!
  name: String!
}

input OfficeCreateOneWithoutEmployeesInput {
  connect: OfficeWhereUniqueInput
  create: OfficeCreateWithoutEmployeesInput
}

input OfficeCreateWithoutEmployeesInput {
  id: ID
  location: String!
  name: String!
}

type OfficeEdge {
  cursor: String!
  node: Office!
}

enum OfficeOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  location_ASC
  location_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input OfficeUpdateInput {
  employees: EmployeeUpdateManyWithoutOfficeInput
  location: String
  name: String
}

input OfficeUpdateManyMutationInput {
  location: String
  name: String
}

input OfficeUpdateOneWithoutEmployeesInput {
  connect: OfficeWhereUniqueInput
  create: OfficeCreateWithoutEmployeesInput
  delete: Boolean
  disconnect: Boolean
  update: OfficeUpdateWithoutEmployeesDataInput
  upsert: OfficeUpsertWithoutEmployeesInput
}

input OfficeUpdateWithoutEmployeesDataInput {
  location: String
  name: String
}

input OfficeUpsertWithoutEmployeesInput {
  create: OfficeCreateWithoutEmployeesInput!
  update: OfficeUpdateWithoutEmployeesDataInput!
}

input OfficeWhereInput {
  AND: [OfficeWhereInput!]
  employees_every: EmployeeWhereInput
  employees_none: EmployeeWhereInput
  employees_some: EmployeeWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  location: String
  location_contains: String
  location_ends_with: String
  location_gt: String
  location_gte: String
  location_in: [String!]
  location_lt: String
  location_lte: String
  location_not: String
  location_not_contains: String
  location_not_ends_with: String
  location_not_in: [String!]
  location_not_starts_with: String
  location_starts_with: String
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [OfficeWhereInput!]
  OR: [OfficeWhereInput!]
}

input OfficeWhereUniqueInput {
  id: ID
  name: String
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Query {
  department(where: DepartmentWhereUniqueInput!): Department
  departments(after: String, before: String, first: Int, last: Int, orderBy: DepartmentOrderByInput, skip: Int, where: DepartmentWhereInput): [Department!]!
  departmentsConnection(after: String, before: String, first: Int, last: Int, orderBy: DepartmentOrderByInput, skip: Int, where: DepartmentWhereInput): DepartmentConnection!
  employee(where: EmployeeWhereUniqueInput!): Employee
  employees(after: String, before: String, first: Int, last: Int, orderBy: EmployeeOrderByInput, skip: Int, where: EmployeeWhereInput): [Employee!]!
  employeesConnection(after: String, before: String, first: Int, last: Int, orderBy: EmployeeOrderByInput, skip: Int, where: EmployeeWhereInput): EmployeeConnection!
  office(where: OfficeWhereUniqueInput!): Office
  offices(after: String, before: String, first: Int, last: Int, orderBy: OfficeOrderByInput, skip: Int, where: OfficeWhereInput): [Office!]!
  officesConnection(after: String, before: String, first: Int, last: Int, orderBy: OfficeOrderByInput, skip: Int, where: OfficeWhereInput): OfficeConnection!
}
